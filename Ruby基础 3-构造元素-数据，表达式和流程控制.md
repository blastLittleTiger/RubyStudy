## Ruby 基础3 构造元素：数据，表达式和流程控制

### 数字与表达式
  
计算机在最底层是基于数字的，所有东西都用数字流表示。Ruby之类的语言将你与计算机内部运算隔离开来。而Ruby中使用的数字与实际生活中使用的数字几乎完全相同！

#### 表达式基础知识
在编程时，表达式（expression）是指数字，运算符（例如+或者-）和变量的组合，当计算机理解此表达式时，我将以某种回答形式得出结果，Ex：

<code>
  5

  1+2

  "a"+"b"+"c"

  100-5*(2-1)

  x+y
</code>

表达式普遍用于所有计算机程序,不仅仅是数字,然而,一旦理解了表达式和运算符对数字的处理方式,就可以立即明白它们是怎样处理文本,列表和其他东西

#### 变量
由于变量是值和数据的占位符,因此还可以把表达式的值赋给变量,还可以用于表达式本身.

<code>
  x=10
  y=x*100
  x += y
  puts x

  age = 24
  puts "You're NOT a teenager" unless age.between?(12, 20)
</code>

`unless`关键字是得到相反的结果
`between？`方法，如果对象处于（或等于）指定的两个值之间，则该方法返回true

自己写了长一点的代码：

<code>
  class Pet
    attr_accessor :name, :age, :gender
  end

  class Person < Pet
  end

  yuan = Person.new
  yuan.name = "Xiaoyuan"
  yuan.gender = "male"
  yuan.age = 24
  puts "You're a working age man" if yuan.gender = "male" && (yuan.age >= 18 && yuan.age <= 65)
</code>

循环打印5次"Test"

<code>5.times do puts "Test" end 或者  5.times {puts "Test"}</code>

我们要先习惯花括号的单行代码,但是对于更长代码块也会使用do和end.这是一种值得养成的好习惯,因为几乎所有专业的Ruby开发人员都遵循这种习惯.

Ruby中的一种创建循环的机制,叫做迭代子(iterator).所谓迭代子,是指再列表条目中逐步递进的东西.

EX: 
1.upto(5) {…code to loop here…}
10.downto(5) {…code to loop here…}
0.step(50,5){…code to loop here…}
  
  <code>
  1.upto(5) {|number| puts number}

  1.upto(5) do |number|
    puts number
  end
  </code>

#### 浮点数

<code>
x=10
y=3
puts x.to_f/y.to_f
</code>

在此情况下，当进行除法运算的时候，x和y都已用Integer类的to_f方法，转换成浮点的等价形式，同样，浮点数也可以用to_i方法，反向转换成整数。

<code>
puts 5.7.to_i
</code>

#### 常量
需要把数据作为计算机程序的直接组成部分的情况极其罕见,这再大多数情况下是正确的,但考虑一下某些永远不会改变的值--例如圆周率的值.这些不改变的值称为常量(constant),再Ruby中的表示形式是以大写字母开头的变量名:

`Pi = 3.141592`
如果此时尝试修改Pi的值,irb会允许修改,但是会给出警告/
`Pi = 500`
`(irb): warning: already initialized constant Pi`

### 文本与字符串
#### 字面字符串
字符串是一组任意长度文本字符(包括数字,字母,空格和符号)的几何.再Ruby中所有字符串都是String类的对象,正如调用字符串的class方法所发现的那样,它返回结果如下:
`puts "Hello, World!".class`
`>>String`

用前文所示的引号,把字符串直接嵌入在代码中,这种构造就称为字面字符串(String literal).这与另一种字符串不同,后者的数据来自远程源,例如来自用户输入,文件或因特网,而预先嵌入在程序中的文本都是字面字符串.
与数字相似,我们可对字符串进行操作,相加和比较,也可以把字符串赋值给变量:

<code>
x = "Test"
y = "String"
puts "Success!" if x+y = "TestString"
</code>

引号只适合单行文本,但是如果想扩展到多行,可以试试下面的方法:

<code>
x=%q{This is a test
of the multi
line capabilities}
</code>

再本例中,引号被替换成%q{和}.当然,不必非得用花括号,也可以用<和>,(和),或只是自选的两个分界符,例如!和!.这段代码可以改写成如下形式,其含义完全相同:

<code>
x=%q!This is a test
of the multi
line capabilities!
</code>

然而,必须记住一点,如果使用惊叹号作为分界符,那么所引用正文中一旦有惊叹号,就会导致这种方法出错.如果字符串中有分界符符号,则字面字符串会提前终止,Ruby会把后面的文本内容视为错误内容.因此,请慎重选择所用的分界符.

另外一种构建字面字符串的方法,是用引入文档(here document),这个概念出自许多其他编程语言.它的构建方式与上例类似,不同之处在于分界符可用多个字符.如:

<code>
  x = <<END_MY_STRING_PLEASE
  This is the string
  And a second line
  END_MY_STRING_PLEASE
</code>

本例中,`<<`标记了字面字符串的开始,后跟所选择的分界符.字面字符串从下一行开始.以再次遇到分界符为结束,采用这种方法,就不大可能碰到选错分界符的问题,只要你有足够的创意即可!

#### 字符串表达式
用+号可以把"Test"和"String"这两个字符串连接起来,得到"TestString",从而使下面的比较结果为true,进而向屏幕输出"Success!":

<code>
  puts "Success!" if "Test"+"String" == "TestString"
</code>

同样,也可以对字符串进行乘法操作.
`puts "abc" * 5`
也可以进行大于和小于的比较操作:
字符以数值形式驻留再计算机内存中,因此每个字母和符号都有值.称为ASCII值.这些值本身没有特别重要的含义,但是却让我们可以用这种方法,对字母甚至更长的字符串进行比较.如果想知道某个字符的值是多少,可以用如下方法:
`puts ?x` (此方法是Ruby1.8中的方法,如果要再1.9版本中查询ASCII值,则如下:`puts ?x.ord`), 可以用String类的chr方法,得到相反的效果.

#### 插写
puts方法把代码的结果打印输出到屏幕上,但是这个结果需要稍作解释.如果随便哪个用户过来使用你的代码,就不会很清楚将产生什么结果,因为他们没兴趣读你的源代码.就不会很清楚将产生什么结果,因为他们没兴趣读你的源代码,因此,你的程序提供用户友好的输出是一件很重要的事,在本例中可以回头使用数字:

<code>
  x=10
  y=20
  puts "#{x}+#{y}=#{x+y}"
</code>

这里展示了一个有意思的能力,即可以把表达式(甚至代码逻辑)直接嵌入到字符串中,之一过程称为插写(interpolation).插写是指表达式结果插入字面字符串的过程.再字符串中插写的方式,是把表达式放在#{和}符号中.
Ex:`puts "100 * 5 = #{100*5}"`

代码段#{100*5}把100*5的结果插写到字符串中指定位置,产生如上所示的输出.
当然也可以插写其他字符串:

<code>
  x="cat"
  puts "The #{x} in the hat"
</code>

或者使用下边更巧妙的办法
`puts "It's a #{"bad " *5}world!`

插写也可以用在字符串赋值中:

<code>
  my_string = "It's a #{"bad"*5}world!"
  puts my_string
</code>

值得一提的是,不用插写方式,把表达式放在字符串之外,也可以得到和前面相同的结果.
<code>
  x=10
  y=20
  puts x.to_s+"x"+y.to_s+"="+(x+y).to_s
  puts "#{x}+#{y}=#{x+y}"
</code>

这两个puts代码产生相同的呃输出,第一行代码用字符串相加,把几个不同的字符串链接起来,x和y的数值用其to_s方法转换成字符串.而第二行puts代码则用插写方式,不需要显式的把数字转换成字符串.

#### 字符串方法
##### 对字符串"Test"调用不同方法的结果

  1. "Test"+"Test"  == TestTest
  2. "Test".capitalize == Test
  3. "Test".downcase == test
  4. "Test".chop == Tes
  5. "Test".hash == -98625764
  6. "Test".next == Tesu
  7. "Test".reverse == tseT
  8. "Test".sum == 416
  9. "Test".swapcase == tEST
  10. "Test".upcase == TEST
  11. "Test".upcase.reverse == TSET
  12. "Test".upcase.reverse.next == TESU

第二章用到的另外一个方法是length
`puts "This is a test".length`
这些方法都很有用,但你无法用这些方法对字符串做什么特别令人耳目一新的事情.

#### 正则表达式与字符串操作
要在搞基层面处理字符串,必须学会正则表达式(regular expression).从根本上说,正则表达式就是搜索查询,不要把它与本章讨论过的表达式混淆起来,如果再喜欢的搜索引擎中输入ruby,你是期望看到关于Ruby的信息.同样,如果你的正则表达式是ruby,并对某个很长的字符串运行该查询,则你期望得到的是相匹配的内容.因此,正则表达式是一个字符串,它描述再其他字符串中的匹配元素模式.

##### 替换
对于字符串,经常要做的操作之一,就是把某些内容替换成其他内容.
`puts "foobar".sub('bar', 'foo')`
本例,对字符串调用名为sub的方法,该方法把第一次遇到的'bar'替换成'foo',替换的结果为foofoo. sub方法只对发现的第一个匹配文本做一次替换,而gsub方法则对所有匹配的文本进行多次替换. `puts "this is a test".gsub('i','')`
这里把所有字母'i'都替换成空字符串.

<code>
  x="This is a test"
  puts x.sub(/^../, 'Hello')
</code>

在本例中,用sub进行了单个替换,传递给sub方法的第一个参数不是字符串,而是正则表达式,斜杠用于表示正则表达式的开始和结尾.在正则表达式中^..,其中^称为锚,表示正则表达式将从字符串中的任一行开头进行匹配.至于两点,每个点都表示"任何字符".综上可知, `/^../` 表示"某行开始的开头两个字符",因此,"This is a test"中的Th被替换成Hello.

同样,入股偶要改变最后两个字母,可以用另外一种锚:

<code>
x = "This is a test"
puts x.sub(/..$/, 'Hello')
</code>

这一次,正则表达式匹配字符串中任一行行尾的两个字符

**注:如果想锚到字符串的绝对开头和结尾,可以相应使用\A和\Z,而^和$则表示各行的开头和结尾.**

##### 用正则表达式进行迭代
在前文中,用过迭代子再数字集合中移动,例如从1计数到10, 如果想在字符串中迭代,并分别访问其各个部分,应该怎么办?scan正式所需要的迭代子方法:

`"xyz".scan(/./) {|letter| puts letter}`

scan方法正如其名,它根据传给它的正则表达式,在字符串中扫描,寻找所有匹配正则表达式的内容.再本例的情况下,提供的正则表达式是每次查找一个字符,这就是分别得到x,y,z输出的原因.查找到的每个字母都被送给代码快,并赋值给letter变量,然后打印到屏幕上.我们再试试下面这个更复杂的例子:

`"This is a test".scan(/../) {|x| puts x} `

这一次,一次扫描了两个字符.
当然,扫描所有字符会产生有些怪异的输出,如空格也混杂在内,我们来调整一下正则表达式,让它值匹配字母和数字,如下:

`"This is a test".scan(/\w\w/){|x| puts x}`

在正则表达式中,有一些特殊字符以反斜杠表示,他们有特殊意义. `\w` 表示"字母表中的任何字符或下划线".还有很多其他字符:

###### 正则表达式中基本的特殊字符和符号
1. ^ 用于行还是的锚
2. $ 用于航结束的锚
3. \A 用于字符开始的锚
4. \Z 用于字符结束的锚
5. . 任一字符
6. \w 任何字母,数字或下划线
7. \W 不匹配\w的任何内容
8. \d 任何数字
9. \D 不匹配\d的任何内容(非数字)
10. \s 空白(空格,制表符,换行符等)
11. \S 非空白(任何可见字符)

利用上边的知识,可以轻易地从字符串中解析出数字

<code>
"The car costs $1000 and the cat costs $10".scan(/\d+/) do |x|
  puts x
end
</code>

<code>
  "The car costs $1000 and the cat costs $10".scan(/\d/) do |x|
    puts x
  end
</code>

因此,在正则表达式中,字符之后的+表示匹配一个或多个此类字符.还有其他种类的修饰符,如:

1. \* 匹配零次或多次前面紧跟的字符,并尽量多的匹配
2. \+ 匹配一次或多次前面紧跟的字符,并尽量多的匹配
3. \*? 匹配零次或多次前面紧跟的字符,并尽量少的匹配
4. \+? 匹配一次或多次前面紧跟的字符,并尽量少的匹配
5. ? 要么匹配一次,要么全不匹配前面紧跟的字符
6. \{x} 匹配x次前面紧跟的字符
7. \{x,y} 匹配最好x次,最多y次前面紧跟的字符

对于正则表达式,目前需要理解的最后一个重要方面,是字符类别(character classes).这些字符类别让可以针对特定字符集合进行匹配.例如,可以扫描字符串中所有元音字母.
`"This is a test".scan(/[aeiou]/) {|x| puts x}`
[aeiou]表示"匹配任何a,e,i,o或u".还可以在方括号中指定字符的范围,如下所示:
`"This is a test`.san(/[a-m]/) {|x| puts x}
这次扫描匹配a到m之间的所有小写字母.
###### 匹配查询
做替换和从字符串中解析某些文本是很有用的,但有时我们只想检查某个字符串是否匹配所选择的模式.例如,可能想快速得知字符串是否包含原因字母:
`puts "String has vomele" if "This is a test" =~ /[aeiou]/`
在本例中, =~是运算符的另一种形式--匹配查询运算符.如果字符串与运算符后边的正则表达式能够匹配,则该表达式结果为true,当然,也可以做相反的操作:
`puts "String contains o digits" unless "This is a test" =~ /[0-9]/`
这一次,代码的含义是除非0到9的数字匹配测试字符串,否则就告诉用户,字符串中没有数字.

还可以使用String类提供的名为match的方法, =~是根据正则表达式是否匹配字符串,返回true或false,而match方法则提供了许多更强大的能力.下边是一个简单的例子:
`puts "String has vowels" if "This is a test".match(/[aeiou]/)`

这行代码看起来与前面的例子几乎一样,但是由于match方法不需要用正则表达式作为参数,它把提供给它的任何字符串都转换成正则表达式,因此下面这行代码也同样可以:
`puts "String has vowels" if "This is a test".match("[aeiou]")`

如果正则表达式能由用户提供,或从文件及其他外部来源载入,这种功能是非常有用的.

在正则表达式中,如果其中一部分由括号(和)包围,则该部分正则表达式所匹配的数据可以单独使用,与剩余的其他数据不想干.match方法让你可以访问这些数据:

<code>
  x = "This is a test".match(/(\w+)(\w+)/)
  puts x[0]
  puts x[1]
  puts x[2]
</code>

match 方法返回MatchData对象,该对象的访问方法与数组类似.第一个元素包含整个正则表达式所匹配的数据,但每个后续元素都只包含正则表达式每块但愿所匹配的内容.在本例中,第一块(\W+)匹配This,而第二块(\w+)则匹配is.

**匹配查询可能比上述内容更复杂,当你开始编写第一个完整的Ruby程序时,我将在下一章讨论更搞基的用法.**

#### 数组与列表
在Ruby中,可以用数组(array)来表示对象的有序集合

##### 基本数组
下面是一个基本的数组:
`x = [1,2,3,4]`
这个数组有四个元素,每个元素都是整数,用逗号分割相邻的两个元素,所有元素都包含在方括号中.
可通过元素的索引序号(即其在数组中的位置)来访问它们,要访问特定的元素,数组或包含数组的变量,可通过包含在方括号中的索引,称其为元素引用(element reference).例如:

<code>
  x = [1, 2, 3, 4]
  puts x[2]
</code>

要改变元素的值,可以直接对其赋予新值,也可以像本章前文中操作数字和字符串一样操作元素.

<code>
  x[2] += 1
  puts x[2]
</code>

or

<code>
  x[2] = "Fish"*3
  puts x[2]
</code>

数组不需要设置预定义空间,或手工分配元素.我们可以创建空数组,如: `x[]`
这个数组是空数组,因此如果定位某个元素,例如`x[5]`,将返回空值.然而我们可以用压入数据的方法,向数组末尾加入内容.如:

<code>
  x = []
  x << "word"
</code>

在此操作之后,数组即包含某个元素:"word"字符串.对于数组来说,<<是把数据放到数组末尾的运算符,也可以调用push方法,他们具有相同的效果.
还可以从数组中一个个的删除数据.传统上讲,数组是个"先进先出"系统,数据既能被压入数组末尾,也能从数组末尾弹出(弹出是从数组末尾检索数据并同事将其删除的过程).

<code>
  x = []
  x << "word"
  x << "Play"
  x << "Fun"
  puts x.pop
  puts x.pop
  puts x.length
</code>

把"word", "Play"和"Fun"压入到x所持有的数组中,然后在屏幕显示首先被"弹出"的元素.元素从数组末尾倒序弹出,因此Fun首先弹出,然后是Play.为了进行良好的度量,随即调用命名为length的方法(也可以用size方法,结果一样),此时数组的长度为1,因为当前数组中只有"Word".
另一个有用的特点是,如果数组中全都是字符串,可以对该数组调用名为join的方法,如果把所有元素链接起来,则形成一个大字符串:

<code>
  x = ["word", "play", "Fun"]
  puts x.join
</code>

join方法可接受一个可选参数,放在结果字符串的每个元素之间

<code>
  x=["word", "paly", "fun"]
  puts x.join(', ')
</code>

这一次,把数组元素链接起来,但在每个元素之间放了逗号和空格.这个输出结果看起来更简洁.

##### 字符串切分成数组
在关于字符串的章节中,用scan方法在字符串内容中迭代扫描,查找匹配正则表达式模式的字符.对于scan方法,你使用了一个代码块,它接受每次查找字符的集合,并将其显示在屏幕上.然而,如果不用代码块进行扫描,它将返回一个数组,包含字符串中所有匹配的内容.如:
`puts "This is a test".scan(/\w/).join(', ')`

















